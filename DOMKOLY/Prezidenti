import pandas 
presidents = pandas.read_csv("1976-2020-president.csv")
#print(presidents.head(30))

# jen sloupečky, které jsou uvedeny jako důležité (year, state, party_simplified, candidatevotes, totalvotes) 
presidents = presidents.loc[:, ["year", "state", "party_simplified","candidatevotes", "totalvotes"]]
#print(presidents.head(30))

# seřazení podle roků a  + pořadí podle počtu hlasů v jednotlivých státech;
# předpokládám, že kdyby náhodou měli 2 stejný počet hlasů, budou mít stejné vyšší pořadi ? 

presidents["ranking"] = presidents.groupby(["state","year"])["candidatevotes"].rank(method="max", ascending = False)
#print(presidents.head(50))

# jen vítězové v každém roce dle států, dotazování:

winners_only = presidents[presidents["ranking"]==1]
#print (winners_only.head(30))
#print (winners_only.tail(30))

# nyní mám za každý stát jednoho vítěze (resp. stranu, která v daném roce zvítězila), ale 
# musím to seřadit podle států, ne podle let, abych mohla použít metodu shift . Řadit 
#se bude podle od nejsrarších voleb po nejnovější a státy podle abecedy od A. 

winners_only=winners_only.sort_values(["state","year"], ascending=[True, True])
#print (winners_only.head(30))
#print (winners_only.tail(30))

# s pomocí metody shift()vytvořit nový sloupec s názvev vítezsné strany v následujícím roce

winners_only["next_election_winner"]=winners_only.groupby(["state"])["party_simplified"].shift(-1)
#print (winners_only.head(30))
#print (winners_only.tail(30))

# zkusím nadefinovat funkci, která bude vracet 0 (beze změny), 1(změna strany)
def party_change (row): 
    for state in row.loc["state"]: 
        if pandas.isnull(row["next_election_winner"]):
            return None 
        elif row.loc["party_simplified"] == row.loc["next_election_winner"]:
            return 0
        else:
            return 1
        

winners_only["result_change"]=winners_only.apply(party_change, axis=1)      

#print (winners_only.head(30))
#print (winners_only.tail(30))

# teď by mělo jít pomocí sum zjistit, kdo měl nejvíc změn. 
# ale protože result change je dichotomická proměnná s hodnota,i 0, 1, tak 
# by to mělo jít i pomocí mean() (analogicky k přežil/nepřežil na Titanicu, dle M.Kovář?)

